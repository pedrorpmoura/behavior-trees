% Chapter Template

\chapter{Linguagem} % Main chapter title
\label{Chapter3} 

\textbf{TODO: breve introdução ao capítulo}
\section{Estrutura de um ficheiro}
Um comportamento pode ser visto como um programa. Cada ficheiro, ao qual designamos de ``ficheiro de comportamento'', descreve um e só um comportamento.

Um ficheiro de comportamento está dividido em 3 partes:
\begin{itemize}
    \item \textit{Comportamento} - especificação da BT que descreve o comportamento representado pelo ficheiro.
    É análogo à função \textit{main} de um programa.
    \item \textit{Definições} (opcional) - definições de nodos (ou sub-árvores) que podem ser referenciadas noutros nodos ou na árvore de comportamento.
    \item \textit{Código} - código em \textit{Python} onde são descritos os nodos de execução, e código extra que o programador deseje utilizar.
\end{itemize}


\section{Sintaxe}
\subsection{Comportamento}
Um comportamento é especificado da seguinte forma:
\begin{lstlisting}
    behavior : [
        tree
    ]
\end{lstlisting}
onde \texttt{tree} é um dos nodos referidos anteriormente, cada um com a sua própria sintaxe (seguindo a estrutura do capítulo anterior):
\begin{figure}[H]
\centering
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    sequence : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    selector : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\end{figure}
\begin{figure}[H]
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    prob_selector : [
        P1 -> child1,
        P2 -> child2,
        ...
        Pn -> childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    parallel : M [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    decorator : POLICY [
        child
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    condition : $CONDITION

    action : $ACTION
\end{lstlisting}
\end{subfigure}
\end{figure}

Se repararmos, os \textit{execution nodes} são definidos por um nome antecedido de um `\texttt{\$}', que é uma referência para algo. Neste caso este algo é uma função, que obrigatoriamente tem de estar definida na parte do \textit{código} do ficheiro.

Os \textit{control flow nodes} também podem ser escritos com esta notação, sendo que nome em questão tem de existir no conjunto de \textit{definições} do ficheiro.

\subsection{Definições}
As definições são \textit{control flow nodes} etiquetados com um nome.
A sua sintaxe é bastante semelhante à apresentada em cima:
\begin{figure}[H]
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    sequence NAME : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    selector NAME : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    prob_selector NAME : [
        P1 -> child1,
        P2 -> child2,
        ...
        Pn -> childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    parallel NAME : M [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    decorator NAME : POLICY [
        child
    ]
\end{lstlisting}
\end{subfigure}
\end{figure}


\subsection{Código}
Nesta parte do ficheiro escrevemos código \textit{Python} que será compilado juntamente com o ficheiro de comportamento.
Aqui têm de estar definidos quaisquer nodos de execução usados no comportamento ou nas definições.