% Chapter Template

\chapter{Linguagem} % Main chapter title
\label{Chapter3} 

\textbf{TODO: breve introdução ao capítulo}
\section{Estrutura}
Um comportamento pode ser visto como um programa. Cada ficheiro, ao qual designamos de ``ficheiro de comportamento'', descreve um e só um comportamento.

Um ficheiro de comportamento está dividido em 3 partes:
\begin{itemize}
    \item \textit{Comportamento} - especificação da BT que descreve o comportamento representado pelo ficheiro.
    É análogo à função \textit{main} de um programa.
    \item \textit{Definições} (opcional) - definições de nodos (ou sub-árvores) que podem ser referenciadas noutros nodos ou na árvore de comportamento.
    \item \textit{Código} - código em \textit{Python} onde são descritos os nodos de execução, e código extra que o programador deseje utilizar.
\end{itemize}


\section{Sintaxe}
\subsection{Comportamento}
Um comportamento é definido da seguinte forma:
\begin{lstlisting}
    behavior : [
        tree
    ]
\end{lstlisting}

Dentro do comportamento, podemos criar a nossa árvore.
Seguindo a estrutura do capítulo anterior, os nodos podem ser especificados das seguintes formas:
\begin{figure}[H]
\centering
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    sequence : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    selector : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\end{figure}
\begin{figure}[H]
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    prob_selector : [
        P1 -> child1,
        P2 -> child2,
        ...
        Pn -> childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    parallel : M [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    decorator : POLICY [
        child
    ]
\end{lstlisting}
\end{subfigure}
\end{figure}

\subsection{Definições}
Basicamente, as definições são nodos etiquetados com um nome, logo a sintaxe é muito parecida:
\begin{figure}[H]
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    sequence NAME : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    selector NAME : [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    prob_selector NAME : [
        P1 -> child1,
        P2 -> child2,
        ...
        Pn -> childn
    ]
\end{lstlisting}
\end{subfigure}
\hfil
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    parallel NAME : M [
        child1,
        child2,
        ...
        childn
    ]
\end{lstlisting}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
\begin{lstlisting}
    decorator NAME : POLICY [
        child
    ]
\end{lstlisting}
\end{subfigure}
\end{figure}
\subsection{Código}